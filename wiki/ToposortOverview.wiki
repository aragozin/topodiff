#summary Introduction to algorithm
#labels Phase-Requirements,Phase-Design,toposort
_Please also look at [http://www.w3.org/DesignIssues/Diff], this article will give you good overview of problem._
= Introduction =

There are to main obstacle to calculate delta between two RDF graphs:
  * there is no some _normal form_ for serialized RDF graph
  * b-nodes (anonymous nodes) are indistinguishable by themselves only by context 
These are actually two faces of same problem, solution to either of them will solve other.

== Normal serialized presentation of RDF graph ==

||Normal serialized form (NSF) of graph - it is some binary presentation of graph, which satisfies following conditions <br> 1. Every graph has only one possible NSF <br/> 2. If two graphs are isomorphic they have equivalent  NSF||

RDF graph is a set of triples. If we could establish linear order over triples, it would be possible to define NSF as sorted list of triples. Unfortunately it is not possible because triple may contain b-nodes and we cannot compare b-nodes without context. But if we define some distinguishing context for b-node we can define linear orders over triples, and sort graph in unique way.
[ToposortAlgorithm Toposort] algorithm implements this idea.

Now we have normal serialized presentation of graph. We can use it directly to calculate difference, but actually this form is not very suitable for it. There are two reasons why it is not good for diff:
  # [ToposortAlgorithm Toposort] can be quite slow on large graphs
  # Changes in one subgraph may result completely different order of b-node appearance and numbering, so many triple will be reported as different, event if they can match each other.

== Sorting of small subgraphs instead of triples ==
Let’s go back to the idea of using sorted list of triples to efficiently calculate graph difference. While we cannot define linear order over triples we can define order over subgraphs (by lexicographically comparing NSF). We can represent graph as set of subgraphs, sort it, and use sorted list to easily calculate delta (delta will actually contain added and removed subgraphs, not triples).
Rules for splitting triples into subgraph are:
||Rule set #1||
|| 1. Each triple, which contains no b-nodes, is a subgraph by itself (single triple subgraph) <br/> 2. In graph of remaining triples all connected component is a separate subgraph||
In subgraph generated by rule 2, every triple has at least one b-node, so let’s call it b-cluster.
_(I think such decomposition is called RDF molecules)_

== Problem of big b-cluster ==
In some cases (it depends on ontology) b-clusters may become too big. This is bad from both performance and quality point of view. Solution is two break such b-cluster to smaller ones. 

Let’s modify the rules:
||Rule set #2||
|| 1. Each triple, which contains no b-nodes, is a subgraph by itself (single triple subgraph) <br/> 2. Each triple having anonymous subject and object, and specific verb, is a subgraph by itself <br/> 3. In graph of remaining triples all connected component is a separate subgraph||
_(which verbs to consider specific depends on ontology)_

[ExapmleBCluster]

== Generic approach to define subgraph ==
Actually any rule to split graph into list of subgraph will do. So it is possible that some other ontology will require completely different subgraph rules. Then only condition to satisfy -  _each triple from original graph should belong exactly one subgraph_. Quality and granularity of delta highly depends on how well subgraph rules are suited for given ontology.

== Actually calculation delta between two RDF graphs ==
Now then all bricks are ready, calculating difference is simple.
=== Step 1 ===
Prepare serialized form of each graph. For each graph:
  # split it into set of subgraphs
  # make sorted list of subgraphs (by lexicographically comparing NSF of subgraphs)
=== Step 2 ===
Now we should calculate delta by traversing two sorted list of subgraphs.
If no two different subgraph can contain same b-node, this step is trivial.
_(Otherwise it is more tricky please see PracticalDiffImplementation for details)_
 
== Performance consideration ==
*Step 1* has mostly _O(ln(n))_ complexity from number of triples (ToposortAlgorithm is a _O(e^m^)_ (_m_ number of triples in subgraph) in worst case, but subgraphs *_should_* be quite small, so we can ignore this).

*Step 2* has mostly _O(n)_ complexity from number of triples, and mostly constant memory requirements (again, some subgraph matching logic may be more complex, but this complexity proportional to number of triples in graph, but to number of triples in subgraph or size of isomorphic subgraphs subset). 

_Tested on graph containing millions of triples this approach has shown very good performance_ 